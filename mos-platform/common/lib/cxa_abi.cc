#include <cstdint>
#include <exception>
#include <new>
#include <typeinfo>

#include <stdio.h>
#include <stdlib.h>

/** Trivial implementation of __cxa_guard_acquire and __cxa_guard_release
 *  as described in the c++ Itanium ABI.
 *
 *  Calls to these functions are generated by the compiler when it needs
 *  to ensure one-time initialization of non-global static variables.
 *
 *  According to the Itanium C++ ABI standard, section 3.3.3:
 *  "As described in Section 2.8, certain objects with static storage duration
 * have associated guard variables used to support the requirement that they be
 * initialized exactly once, the first time the scope declaring them is entered.
 * An implementation that does not anticipate supporting multi-threading may
 * simply check the first byte (i.e., the byte with lowest address) of that
 * guard variable, initializing if and only if its value is zero, and then
 * setting it to a non-zero value."
 *
 * Since this is intended to be a simple single-threaded implementation, we take
 * the advice presented and just initialize the first byte of the 64-bit guard
 * object.  The remaining 7 bytes are unused (but required to be present by the
 * ABI standard)
 */

extern "C" __attribute__((weak)) int
__cxa_guard_acquire(uint64_t *guard_object) {
  // Check if the initializer has run by testing the lowest-address
  // byte for a non-zero value.
  return (*reinterpret_cast<uint8_t *>(guard_object) == 0) ? 1 : 0;
}

extern "C" __attribute__((weak)) void
__cxa_guard_release(uint64_t *guard_object) {
  // set the lowest address byte to a non-zero value.
  *reinterpret_cast<uint8_t *>(guard_object) = 1;
}

extern "C" void __cxa_pure_virtual() {
  puts("PURE VIRTUAL FUNCTION CALLED");
  std::terminate();
}

extern "C" void __cxa_deleted_virtual() {
  puts("DELETED VIRTUAL FUNCTION CALLED");
  std::terminate();
}

namespace std {
type_info::~type_info() noexcept = default;

// "It is intended that two type_info pointers point to equivalent type
// descriptions if and only if the pointers are equal."
// Itanium ABI 2.9
bool type_info::operator==(const type_info &rhs) const noexcept {
  return this == &rhs;
}

bool type_info::operator!=(const type_info &rhs) const noexcept {
  return !operator==(rhs);
}

bool type_info::before(const type_info &rhs) const noexcept {
  // Define ordering by order in memory. Assume all type_info instances
  // are placed in a single, flat address space.
  return this < &rhs;
}

const char *type_info::name() const noexcept { return __type_name; }

} // namespace std

